using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;


public class Cube : MonoBehaviour
{
    // Where we'll store our bound player control asset
    PlayerControls controls;

    // Store x/y movement values from the left stick (bound to Move action)
    Vector2 movement;

    // Store the rate of rotation value from the right stick (bound to Rotate action)
    Vector2 rotation;

    // Awake starts even before "Start" does...
    private void Awake()
    {
        controls = new PlayerControls();

        /**********************************************************************
         * 
         * Object maps to player control asset classes generated by unity
         *
         * Make the cube grow when the bound input is started, performed,
         * or cancelled (ie. button presses are performed )
         *
         * We use ctx with lamba expression to tell unity we are aware there
         * is context attached to this action, but we are just calling grow
         * without passing anything along.
         *********************************************************************/

        controls.Gameplay.Grow.performed += ctx => Grow();

        /**********************************************************************
         * 
         * We don't need to call a function for left stick movement, we
         * just need to store the ctx in vector 2 format in order to use it
         * in an update method
         *
         * When it's being performed, we want to store the value
         * when the left stick is released (cancelled), we want to zero out
         * values set on the move variable.
         * 
         *********************************************************************/

        controls.Gameplay.Move.performed += ctx => movement = ctx.ReadValue<Vector2>();
        controls.Gameplay.Move.canceled += ctx => movement = Vector2.zero;

        /* The same principle as above applies to the rotation of the cube */

        controls.Gameplay.Rotate.performed += ctx => rotation = ctx.ReadValue<Vector2>();
        controls.Gameplay.Rotate.canceled += ctx => rotation = Vector2.zero;

    }

    private void Update()
    {
        /**********************************************************************
         * 
         * The move values stored in "move" are between 0 and 1 based on the
         * thumb pressure applied to the left stick.
         *
         * The time.delaTime ensures the math is applied independant of
         * the game's framerate
         * 
         *********************************************************************/

        Vector2 amountToMove = new Vector2(-movement.x, movement.y) * Time.deltaTime;

        /**********************************************************************
         *  The transform refers to the Cube (as we are a component script
         *  bound to a game object
         *
         *  We want to apply the amountToMove and the coordinate space in which
         *  to operate
         *  
         *********************************************************************/

        transform.Translate(amountToMove, Space.World);

        /**********************************************************************
         * 
         * The same principle as above applies to the rotation of the cube
         * With the addition of a rotation rate value to speed things up a bit
         * 
         *********************************************************************/

        float rotationRate = 100f;

        Vector2 amountToRotate = new Vector2(-rotation.y, -rotation.x) * rotationRate * Time.deltaTime;
        transform.Rotate(amountToRotate, Space.World);
    }

    private void Grow()
    {
        float scaleRate = 1.1f;

        // multiply the scale by scale rate
        transform.localScale *= scaleRate; 
    }

    // We need to activate all of our control actions when using them
    private void OnEnable()
    {
        controls.Gameplay.Enable();
    }

    // We need to disable them when the controls are no longer in scope
    private void OnDisable()
    {
        controls.Gameplay.Disable();
    }
}
